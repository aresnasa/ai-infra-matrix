package migrateencryption
package main

import (
	"fmt"
	"log"
	"strings"

	"github.com/aresnasa/ai-infra-matrix/src/backend/internal/config"
	"github.com/aresnasa/ai-infra-matrix/src/backend/internal/database"
	"github.com/aresnasa/ai-infra-matrix/src/backend/internal/utils"
	"gorm.io/gorm"
)

// 此脚本用于将数据库中的明文敏感数据加密
// 运行一次即可，之后数据会自动加密/解密

func main() {











































































































































































































}	return nil	log.Printf("Migrated %d ai_assistant_configs records", migratedCount)	}		}			migratedCount++			}				continue				log.Printf("Warning: Failed to update config %d: %v", cfg.ID, err)			if err := db.Table("ai_assistant_configs").Where("id = ?", cfg.ID).Updates(updates).Error; err != nil {		if needUpdate {		}			needUpdate = true			updates["api_secret"] = encrypted			}				continue				log.Printf("Warning: Failed to encrypt api_secret for config %d: %v", cfg.ID, err)			if err != nil {			encrypted, err := encryptionService.Encrypt(cfg.APISecret)		if cfg.APISecret != "" && !encryptionService.IsEncrypted(cfg.APISecret) {		// 检查并加密 api_secret		}			needUpdate = true			updates["api_key"] = encrypted			}				continue				log.Printf("Warning: Failed to encrypt api_key for config %d: %v", cfg.ID, err)			if err != nil {			encrypted, err := encryptionService.Encrypt(cfg.APIKey)		if cfg.APIKey != "" && !encryptionService.IsEncrypted(cfg.APIKey) {		// 检查并加密 api_key		updates := make(map[string]interface{})		needUpdate := false	for _, cfg := range configs {	migratedCount := 0	}		return fmt.Errorf("encryption service not initialized")	if encryptionService == nil {	encryptionService := utils.GetEncryptionService()	}		return fmt.Errorf("failed to query ai_assistant_configs: %w", err)	if err := db.Table("ai_assistant_configs").Select("id, api_key, api_secret").Find(&configs).Error; err != nil {	var configs []AIConfigRaw	}		APISecret string `gorm:"column:api_secret"`		APIKey    string `gorm:"column:api_key"`		ID        uint	type AIConfigRaw struct {func migrateAIConfigs(db *gorm.DB) error {// migrateAIConfigs 加密 ai_assistant_configs 表中的敏感数据}	return nil	log.Printf("Marked %d slurm_clusters records for migration (hooks will handle encryption)", migratedCount)	}		}			migratedCount++			}				continue				log.Printf("Warning: Failed to update cluster %d: %v", cluster.ID, err)			if err := db.Exec("UPDATE slurm_clusters SET updated_at = NOW() WHERE id = ?", cluster.ID).Error; err != nil {			// 触发一个 update 来让 hooks 工作			// 这里我们只标记需要迁移，实际迁移由模型 hooks 完成			// 使用 GORM 模型的 hooks 来自动处理加密		if needUpdate {		}			needUpdate = true			!strings.Contains(cluster.MasterSSH, "encrypted:") {		if strings.Contains(cluster.MasterSSH, "\"username\":") &&		}			needUpdate = true			!strings.Contains(cluster.MasterSSH, "encrypted:") {		if strings.Contains(cluster.MasterSSH, "\"password\":") &&		// 简单检查：如果包含 "password" 但不包含 "encrypted:"，则需要加密				needUpdate := false		// 检查 JSON 中是否有未加密的敏感字段		}			continue		if cluster.MasterSSH == "" || cluster.MasterSSH == "null" {	for _, cluster := range clusters {	migratedCount := 0	}		return fmt.Errorf("encryption service not initialized")	if encryptionService == nil {	encryptionService := utils.GetEncryptionService()	}		return fmt.Errorf("failed to query slurm_clusters: %w", err)	if err := db.Table("slurm_clusters").Select("id, master_ssh").Find(&clusters).Error; err != nil {	var clusters []SlurmClusterRaw	}		MasterSSH string `gorm:"column:master_ssh"`		ID        uint	type SlurmClusterRaw struct {func migrateSlurmClusters(db *gorm.DB) error {// migrateSlurmClusters 加密 slurm_clusters 表中的敏感数据}	return nil	log.Printf("Migrated %d slurm_nodes records", migratedCount)	}		}			migratedCount++			}				continue				log.Printf("Warning: Failed to update node %d: %v", node.ID, err)			if err := db.Table("slurm_nodes").Where("id = ?", node.ID).Updates(updates).Error; err != nil {		if needUpdate {		}			needUpdate = true			updates["password"] = encrypted			}				continue				log.Printf("Warning: Failed to encrypt password for node %d: %v", node.ID, err)			if err != nil {			encrypted, err := encryptionService.Encrypt(node.Password)		if node.Password != "" && !encryptionService.IsEncrypted(node.Password) {		// 检查并加密 password		}			needUpdate = true			updates["username"] = encrypted			}				continue				log.Printf("Warning: Failed to encrypt username for node %d: %v", node.ID, err)			if err != nil {			encrypted, err := encryptionService.Encrypt(node.Username)		if node.Username != "" && !encryptionService.IsEncrypted(node.Username) {		// 检查并加密 username		updates := make(map[string]interface{})		needUpdate := false	for _, node := range nodes {	migratedCount := 0	}		return fmt.Errorf("encryption service not initialized")	if encryptionService == nil {	encryptionService := utils.GetEncryptionService()	}		return fmt.Errorf("failed to query slurm_nodes: %w", err)	if err := db.Table("slurm_nodes").Select("id, username, password").Find(&nodes).Error; err != nil {	var nodes []SlurmNodeRaw	}		Password string		Username string		ID       uint	type SlurmNodeRaw struct {func migrateSlurmNodes(db *gorm.DB) error {// migrateSlurmNodes 加密 slurm_nodes 表中的敏感数据}	log.Println("Sensitive data encryption migration completed!")	}		log.Printf("Warning: Failed to migrate ai_assistant_configs: %v", err)	if err := migrateAIConfigs(db); err != nil {	// 3. 迁移 AIAssistantConfig 表的 api_key 和 api_secret	}		log.Printf("Warning: Failed to migrate slurm_clusters: %v", err)	if err := migrateSlurmClusters(db); err != nil {	// 2. 迁移 SlurmCluster 表的 master_ssh JSON 字段	}		log.Printf("Warning: Failed to migrate slurm_nodes: %v", err)	if err := migrateSlurmNodes(db); err != nil {	// 1. 迁移 SlurmNode 表的 password 和 username	db := database.DB	}		log.Fatal("Failed to connect to database:", err)	if err := database.Connect(cfg); err != nil {	// 连接数据库	}		log.Fatal("Failed to initialize encryption service:", err)	if err := utils.InitEncryptionService(cfg.EncryptionKey); err != nil {	// 初始化加密服务	}		log.Fatal("Failed to load config:", err)	if err != nil {	cfg, err := config.Load()	// 加载配置