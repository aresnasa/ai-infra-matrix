events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    # Docker 内置DNS解析器，支持运行时解析容器域名
    resolver 127.0.0.11 ipv6=off;
    
    # 字符集设置
    charset utf-8;
    source_charset utf-8;

    # WebSocket 连接升级映射
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    # Focused auth debug format to inspect auth_request and cookie→Authorization mapping
    log_format authdebug '$remote_addr - [$time_local] $request '
                        'status=$status upstream_status=$upstream_status auth_status=$auth_status '
                        'authz_final=$authz_final has_authz=$has_authz '
                        'ai=$cookie_ai_infra_token jwt=$cookie_jwt_token auth=$cookie_auth_token '
                        'x-user=$upstream_http_x_user x-email=$upstream_http_x_email '
                        'uri=$uri req_uri=$request_uri';

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    gzip on;
    gzip_vary on;
    gzip_min_length 1000;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # Compose Authorization for auth_request: prefer header, then SSO cookies (ai_infra_token -> jwt_token -> auth_token)
    # Sanitize cookie values: treat literal "null"/"undefined" as empty
    map $cookie_ai_infra_token $ai_token_sane { default $cookie_ai_infra_token; "" ""; null ""; undefined ""; }
    map $cookie_jwt_token $jwt_token_sane { default $cookie_jwt_token; "" ""; null ""; undefined ""; }
    map $cookie_auth_token $auth_token_sane { default $cookie_auth_token; "" ""; null ""; undefined ""; }

    map $http_authorization $authz_from_header { default $http_authorization; "" ""; }
    map $ai_token_sane $authz_from_ai { default "Bearer $ai_token_sane"; "" ""; }
    map $jwt_token_sane $authz_from_jwt { default "Bearer $jwt_token_sane"; "" ""; }
    map $auth_token_sane $authz_from_auth { default "Bearer $auth_token_sane"; "" ""; }
    # Prefer Authorization header; if empty, fall back to ai_infra_token
    map $authz_from_header $authz_prefer_header { "" $authz_from_ai; default $authz_from_header; }
    # If still empty (or just 'Bearer '), fall back to jwt_token
    map $authz_prefer_header $authz_fallback_jwt { ~^Bearer\s*$ $authz_from_jwt; "" $authz_from_jwt; default $authz_prefer_header; }
    # If still empty, fall back to auth_token
    map $authz_fallback_jwt $authz_final { ~^Bearer\s*$ $authz_from_auth; "" $authz_from_auth; default $authz_fallback_jwt; }

    # Debug helpers: indicate presence of cookies and authz
    map $ai_token_sane $has_ai_cookie { default "1"; "" "0"; }
    map $jwt_token_sane $has_jwt_cookie { default "1"; "" "0"; }
    map $auth_token_sane $has_auth_cookie { default "1"; "" "0"; }
    map $authz_final $has_authz { ~^Bearer\s*.+$ "1"; default "0"; }

    # Backend upstream - 支持分布式部署
    upstream backend {
        # 支持环境变量配置后端节点
        # 默认: ai-infra-backend:8082 (Docker Compose)
        # 分布式: BACKEND_HOST:BACKEND_PORT
        server ai-infra-backend:8082;
        keepalive 32;
    }

    # JupyterHub 动态上游地址（使用变量避免启动时解析失败）
    # 默认使用 docker compose 服务名 jupyterhub:8000（稳定可解析）
    map $host $jhub_upstream {
        default "jupyterhub:8000";
    }

    # Gitea 动态上游地址（使用变量避免启动时解析失败）
    map $host $gitea_upstream {
        default "gitea:3000";
    }

    # Frontend upstream - 支持分布式部署
    upstream frontend {
        # 支持环境变量配置前端节点
        # 默认: ai-infra-frontend:80 (Docker Compose)
        # 分布式: FRONTEND_HOST:FRONTEND_PORT
        server ai-infra-frontend:80;
        keepalive 32;
    }

    # 分布式部署支持：动态主机变量
    map $http_host $external_host {
        default $http_host;
        # 如果是内部容器访问，使用外部主机
        "~^ai-infra-nginx" $http_x_forwarded_host;
    }

    map $http_x_forwarded_proto $external_scheme {
        default $scheme;
        https https;
        http http;
    }

    server {
        listen 80;
        server_name localhost _;  # 支持任意主机名的分布式访问
        
        # 分布式部署优化：相对重定向避免主机/端口问题
        absolute_redirect off;
        
        # 分布式安全头设置
        add_header X-Frame-Options SAMEORIGIN always;
        add_header X-Content-Type-Options nosniff always;
        add_header X-XSS-Protection "1; mode=block" always;

        # 设置最大请求体大小
        client_max_body_size 100M;

        # =============
        # Gitea SSO 认证子请求：调用后端 /api/auth/verify 检查JWT
        # 成功时后端会在响应头返回 X-User / X-Email
        # =============
        location = /__auth/verify {
            internal;
            # Log each auth subrequest with relevant variables
            access_log /var/log/nginx/auth_request.log authdebug;
            proxy_pass http://backend/api/auth/verify;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $external_scheme;
            proxy_set_header X-Forwarded-Host $external_host;
            # 透传Authorization和Cookie以便后端从JWT中识别用户
            # 使用 map 组合的 Authorization 优先级：Header > ai_infra_token > jwt_token > auth_token
            proxy_set_header Authorization $authz_final;
            proxy_set_header Cookie $http_cookie;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
        }

        # SSO单点登录桥接页面
        location /sso/ {
            alias /usr/share/nginx/html/sso/;
            index jwt_sso_bridge.html;
            try_files $uri $uri/ jwt_sso_bridge.html;
            # Prevent caching so updated bridge logic takes effect immediately
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;
            add_header Pragma "no-cache" always;
            add_header Expires "0" always;
        }
        
        # JupyterHub 认证后的入口 - 跳转到认证桥接，便于附加token
        location = /jupyterhub-authenticated {
            return 302 /jupyterhub-auth-bridge?target_url=/jupyter/hub/;
        }
        
        # JupyterHub 认证桥接页面
        location = /jupyterhub-auth-bridge {
            root /usr/share/nginx/html/jupyterhub;
            try_files /jupyterhub_auth_bridge.html =404;
            add_header Content-Type "text/html; charset=utf-8";
            add_header Cache-Control "no-cache, no-store, must-revalidate";
        }

        # Embedded Jupyter SPA entry: keep /jupyter (no trailing slash) on frontend
        location = /jupyter {
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Gitea root without trailing slash: normalize to /gitea/
        # This ensures the request enters the SSO-protected location ^~ /gitea/
        # instead of being handled by the frontend SPA route, avoiding stray 401s.
        location = /gitea {
            return 302 /gitea/;
        }

    location ^~ /gitea/ {
            # Per-location access log to trace auth_request variables and cookie→Authorization mapping
            access_log /var/log/nginx/gitea_access.log authdebug;
            # Strip /gitea prefix by using proxy_pass with trailing slash
            # This makes /gitea/<path> → http://gitea:3000/<path>
            proxy_pass http://gitea:3000/;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $external_scheme;
            proxy_set_header X-Forwarded-Host $external_host;
            proxy_set_header X-External-Host $external_host;
            # Do not send X-Forwarded-Prefix to avoid confusing upstream routing
            # proxy_set_header X-Forwarded-Prefix /gitea;
            # Do not forward client Authorization to Gitea to avoid confusion with header auth
            proxy_set_header Authorization "";
            # Optional: we can hint prefix to upstream if needed (Gitea usually detects from ROOT_URL)
            # proxy_set_header X-Forwarded-Prefix /gitea;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # SSO via reverse proxy: require auth and inject identity headers for Gitea
            auth_request /__auth/verify;
            error_page 401 = @gitea_sso_redirect;
            error_page 403 = @gitea_sso_redirect;
            # Map headers returned by auth subrequest to upstream request headers
            auth_request_set $auth_user $upstream_http_x_user;
            auth_request_set $auth_email $upstream_http_x_email;
            # Also map X-WEBAUTH-* in case backend sets those
            auth_request_set $auth_user_webauth $upstream_http_x_webauth_user;
            auth_request_set $auth_email_webauth $upstream_http_x_webauth_email;
            # Capture auth subrequest status for debugging
            auth_request_set $auth_status $upstream_status;
            # Forward identity headers to upstream
            # Prefer explicit webauth headers if provided, fallback to generic ones
            set $user_header $auth_user_webauth;
            if ($user_header = "") { set $user_header $auth_user; }
            set $email_header $auth_email_webauth;
            if ($email_header = "") { set $email_header $auth_email; }
            proxy_set_header X-WEBAUTH-USER $user_header;
            proxy_set_header X-WEBAUTH-EMAIL $email_header;
            proxy_set_header X-Forwarded-User $user_header;
            proxy_set_header Remote-User $user_header;
            proxy_set_header X-User $user_header;
            # Debug headers (safe to remove once verified)
            add_header X-Debug-Auth-User $user_header always;
            add_header X-Debug-Auth-Email $email_header always;
            add_header X-Debug-Auth-Status $auth_status always;
            add_header X-Debug-Cookie $http_cookie always;
            add_header X-Debug-URI $uri always;
            add_header X-Debug-Request-URI $request_uri always;

            # Note: Do not use an 'if' here to test $auth_user. The rewrite phase runs
            # before auth_request sets variables, which would incorrectly trigger 401s.

            # Allow same-origin embedding
            proxy_hide_header Content-Security-Policy;
            proxy_hide_header Content-Security-Policy-Report-Only;
            proxy_hide_header X-Content-Security-Policy;
            proxy_hide_header X-Frame-Options;
            add_header X-Frame-Options SAMEORIGIN always;
            # Be explicit about frame ancestors to avoid upstream CSP blocking
            add_header Content-Security-Policy "frame-ancestors 'self'" always;
            proxy_redirect off;

            # Disable caching to avoid intermittent 404s when navigating Gitea within iframe
            proxy_buffering off;
            proxy_request_buffering off;
            add_header Cache-Control "no-store, no-cache, must-revalidate" always;
            expires -1;
        }

        # 未认证时跳转到SSO桥接页面完成登录，然后返回到原始的Gitea路径
        location @gitea_sso_redirect {
            add_header X-Debug-Auth-Status $auth_status always;
            add_header X-Debug-Has-AI $has_ai_cookie always;
            add_header X-Debug-Has-JWT $has_jwt_cookie always;
            add_header X-Debug-Has-AUTH $has_auth_cookie always;
            add_header X-Debug-Has-Authz $has_authz always;
            # Avoid breaking querystring in redirect_uri by passing path and args separately
            return 302 /sso/jwt_sso_bridge.html?service=gitea&redirect_path=$uri&redirect_args=$args;
        }

        # Public debug endpoint: verifies cookie-assembled Authorization against backend
        # Useful to confirm cookies are present and valid without requiring Authorization header
        # NOTE: Keep enabled only in dev/test environments
        location = /debug/verify {
            access_log /var/log/nginx/auth_verify.log authdebug;
            proxy_pass http://backend/api/auth/verify;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $external_scheme;
            proxy_set_header X-Forwarded-Host $external_host;
            proxy_set_header Authorization $authz_final;
            proxy_set_header Cookie $http_cookie;
        }

        # JupyterHub 核心服务代理 - 统一入口点
        # 使用 ^~ 提高优先级，避免被正则静态资源规则 (~* \.(js|css|...)) 抢走，导致转发到前端而产生404
        location ^~ /jupyter/ {
            # 关键修复：
            # 1. 不使用 / 结尾，告知 Nginx 不进行路径替换
            # 2. proxy_pass 到 http://jupyterhub:8000，保留 /jupyter/ 前缀
            # 这样，JupyterHub (配置了 base_url) 才能正确解析路径
            proxy_pass http://jupyterhub:8000;
            
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            proxy_set_header Cookie $http_cookie;
            
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            
            proxy_buffering off;
            proxy_request_buffering off;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
            
            proxy_hide_header Content-Security-Policy;
            proxy_hide_header X-Frame-Options;
            add_header Content-Security-Policy "frame-ancestors 'self' http://localhost:8080;" always;
            add_header X-Frame-Options SAMEORIGIN always;
        }

        # 处理根路径的favicon
        location = /favicon.ico {
            proxy_pass http://$jhub_upstream/favicon.ico;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # JWT 自动登录页面
        location /jwt-login {
            alias /usr/share/nginx/html/jwt_login.html;
            try_files $uri $uri/ =404;
        }

        # 后端API代理 - 分布式部署支持
        location /api/ {
            proxy_pass http://backend/api/;
            
            # 分布式部署代理头
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $external_scheme;
            proxy_set_header X-Forwarded-Host $external_host;
            proxy_set_header X-External-Host $external_host;
            
            # SSO认证支持
            proxy_set_header Authorization $http_authorization;
            proxy_set_header Cookie $http_cookie;

            # 分布式CORS支持 - 动态Origin
            set $cors_origin "*";
            if ($http_origin ~ ^https?://(.*\.)?(localhost|[\d\.]+)(:\d+)?$) {
                set $cors_origin $http_origin;
            }
            
            add_header Access-Control-Allow-Origin $cors_origin always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-External-Host" always;
            add_header Access-Control-Allow-Credentials "true" always;

            # 处理OPTIONS请求
            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin $cors_origin always;
                add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
                add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Requested-With, X-External-Host" always;
                add_header Access-Control-Allow-Credentials "true" always;
                return 204;
            }
        }



        # 测试页面 - 必须在前端路由之前
        location = /test_auth.html {
            root /usr/share/nginx/html;
            add_header Content-Type "text/html; charset=utf-8";
            add_header Cache-Control "no-cache, no-store, must-revalidate";
        }

        # 调试页面
        location = /debug_auth.html {
            # Prefer local static file when baked into image; fallback to default html dir
            root /usr/share/nginx/html;
            try_files /debug_auth.html /debug_auth.html =404;
            add_header Content-Type "text/html; charset=utf-8";
            add_header Cache-Control "no-cache, no-store, must-revalidate";
        }

        # Token设置页面
        location = /token_setup.html {
            root /usr/share/nginx/html;
            add_header Content-Type text/html;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
        }

        # 静态资源缓存（前端）
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            proxy_pass http://frontend;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # 前端应用代理
        location / {
            proxy_pass http://frontend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 健康检查端点
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }

    # 调试专用：直通JupyterHub，不做路径重写，监听8001
    server {
        listen 8001;
        server_name localhost _;
        access_log /var/log/nginx/access.log main;
        error_log /var/log/nginx/error.log;

        location / {
            proxy_pass http://jupyterhub:8000;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        location /health {
            return 200 "debug ok\n";
            add_header Content-Type text/plain;
        }
    }
}