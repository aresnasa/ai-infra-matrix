#!/bin/bash

# AI-Infra-Matrix 三环境统一构建部署脚本
# 支持开发环境、CD服务器、生产环境三种部署模式
# 版本: v3.1.0

set -euo pipefail

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 全局变量
PRIVATE_REGISTRY=""
IMAGE_TAG=""
DOCKER_COMPOSE_FILE="docker-compose.yml"
DOCKER_COMPOSE_BACKUP="docker-compose.yml.backup"

# 环境类型
ENV_TYPE=""  # development, cicd, production
BUILD_MODE="" # local, remote, deploy

# 配置文件
ENV_FILE=""
COMPOSE_PROJECT_NAME=""

# 功能开关
DRY_RUN=false
VERBOSE=false
FORCE_MODE=false

# 检测和设置环境类型
detect_environment() {
    # 优先使用环境变量
    if [[ -n "${AI_INFRA_ENV_TYPE:-}" ]]; then
        ENV_TYPE="$AI_INFRA_ENV_TYPE"
        print_info "使用环境变量设置的环境类型: $ENV_TYPE"
        return 0
    fi
    
    # 自动检测环境
    if [[ -f "/etc/ai-infra-env" ]]; then
        ENV_TYPE=$(cat /etc/ai-infra-env)
        print_info "检测到环境配置文件: $ENV_TYPE"
    elif command -v kubectl &> /dev/null && kubectl cluster-info &> /dev/null; then
        ENV_TYPE="production"
        print_info "检测到Kubernetes环境，设置为生产环境"
    elif [[ -n "${CI:-}" ]] || [[ -n "${JENKINS_URL:-}" ]] || [[ -n "${GITLAB_CI:-}" ]]; then
        ENV_TYPE="cicd"
        print_info "检测到CI/CD环境"
    else
        ENV_TYPE="development"
        print_info "默认设置为开发环境"
    fi
}

# 加载环境配置
load_environment_config() {
    detect_environment
    
    case "$ENV_TYPE" in
        "development")
            ENV_FILE=".env"
            BUILD_MODE="local"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-dev"
            ;;
        "cicd")
            ENV_FILE=".env"
            BUILD_MODE="remote"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-cicd"
            ;;
        "production")
            ENV_FILE=".env.prod"
            BUILD_MODE="deploy"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-prod"
            ;;
        *)
            print_error "未知的环境类型: $ENV_TYPE"
            exit 1
            ;;
    esac
    
    # 加载环境文件
    if [[ -f "$SCRIPT_DIR/$ENV_FILE" ]]; then
        set -a
        source "$SCRIPT_DIR/$ENV_FILE"
        set +a
        print_success "已加载环境配置: $ENV_FILE"
    else
        print_warning "环境文件不存在: $ENV_FILE，使用默认配置"
    fi
    
    # 设置默认值
    IMAGE_TAG="${IMAGE_TAG:-v0.3.5}"
    PRIVATE_REGISTRY="${PRIVATE_REGISTRY:-}"
}

# 从 docker-compose.yml 提取所有镜像
extract_images_from_compose() {
    local compose_file="$1"
    
    # 使用更精确的方式提取镜像
    grep -E "^\s*image:\s*" "$compose_file" | \
    sed -E 's/^\s*image:\s*//g' | \
    sed -E 's/["'\''"]//g' | \
    sort -u
}

# 获取镜像映射名称的函数
get_image_mapping() {
    local original_image="$1"
    
    case "$original_image" in
        "postgres:15-alpine")
            echo "postgres:15-alpine"
            ;;
        "redis:7-alpine")
            echo "redis:7-alpine"
            ;;
        "osixia/openldap:stable")
            echo "openldap:stable"
            ;;
        "osixia/phpldapadmin:stable")
            echo "phpldapadmin:stable"
            ;;
        "nginx:1.27-alpine")
            echo "nginx:1.27-alpine"
            ;;
        "quay.io/minio/minio:latest")
            echo "minio:latest"
            ;;
        "redislabs/redisinsight:latest")
            echo "redisinsight:latest"
            ;;
        "tecnativa/tcp-proxy")
            echo "tcp-proxy:latest"
            ;;
        "ai-infra-backend-init")
            echo "ai-infra-backend-init"
            ;;
        "ai-infra-backend")
            echo "ai-infra-backend"
            ;;
        "ai-infra-frontend")
            echo "ai-infra-frontend"
            ;;
        "ai-infra-jupyterhub")
            echo "ai-infra-jupyterhub"
            ;;
        "ai-infra-singleuser")
            echo "ai-infra-singleuser"
            ;;
        "ai-infra-saltstack")
            echo "ai-infra-saltstack"
            ;;
        "ai-infra-nginx")
            echo "ai-infra-nginx"
            ;;
        "ai-infra-gitea")
            echo "ai-infra-gitea"
            ;;
        *)
            # 默认处理：移除前缀域名
            echo "${original_image##*/}"
            ;;
    esac
}

# 生成私有仓库镜像名称
get_private_image_name() {
    local original_image="$1"
    local registry="$2"
    
    # 移除 registry 末尾的斜杠（如果有）
    registry="${registry%/}"
    
    # 解析原始镜像
    local name tag
    if [[ "$original_image" == *":"* ]]; then
        name="${original_image%:*}"
        tag="${original_image#*:}"
    else
        name="$original_image"
        tag="latest"
    fi
    
    # 处理变量替换
    if [[ "$tag" == *"\${IMAGE_TAG"* ]]; then
        tag="${IMAGE_TAG}"
    fi
    
    # 获取映射名称
    local mapped_name=$(get_image_mapping "$name")
    if [[ -z "$mapped_name" ]]; then
        mapped_name=$(get_image_mapping "$original_image")
    fi
    
    if [[ -z "$mapped_name" ]]; then
        # 默认处理：移除前缀域名
        mapped_name="${name##*/}"
    fi
    
    # 如果映射名称包含标签，使用映射的标签
    if [[ "$mapped_name" == *":"* ]]; then
        echo "${registry}/${mapped_name}"
    else
        echo "${registry}/${mapped_name}:${tag}"
    fi
}

# 构建所有本地镜像（开发环境）
build_all_images() {
    print_info "开始构建所有镜像..."
    
    if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
        print_error "镜像构建仅支持开发环境"
        print_info "当前环境: $ENV_TYPE，如需强制执行请使用 --force"
        exit 1
    fi
    
    # 调用 all-ops.sh 进行构建
    local all_ops_script="$SCRIPT_DIR/scripts/all-ops.sh"
    
    if [[ ! -f "$all_ops_script" ]]; then
        print_error "找不到构建脚本: $all_ops_script"
        exit 1
    fi
    
    chmod +x "$all_ops_script"
    
    print_info "调用构建脚本..."
    if [[ "$VERBOSE" == "true" ]]; then
        "$all_ops_script" build --version "$IMAGE_TAG" --verbose
    else
        "$all_ops_script" build --version "$IMAGE_TAG"
    fi
    
    print_success "所有镜像构建完成"
}

# 下载外网镜像并推送到内网仓库（CD环境）
transfer_images_to_private_registry() {
    local registry="$1"
    local tag="$2"
    
    if [[ "$ENV_TYPE" != "cicd" ]] && [[ "$FORCE_MODE" != "true" ]]; then
        print_error "镜像转发功能主要用于CI/CD环境"
        print_info "如果确认要在当前环境执行，请使用 --force 参数"
        exit 1
    fi
    
    print_info "开始镜像转发: 外网 -> $registry"
    
    # 检查Docker登录状态
    if ! docker info > /dev/null 2>&1; then
        print_error "Docker服务未运行"
        exit 1
    fi
    
    # 获取所有需要的镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    local transfer_success=0
    local transfer_failed=0
    
    print_info "开始转发镜像列表:"
    echo "$images" | while read -r original_image; do
        if [[ -n "$original_image" ]]; then
            echo "  - $original_image"
        fi
    done
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量
            local processed_image="$original_image"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                processed_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                processed_image="${processed_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$processed_image" "$registry")
            
            print_info "转发镜像: $processed_image -> $private_image"
            
            # 检查本地是否已存在
            if docker image inspect "$processed_image" >/dev/null 2>&1; then
                print_info "使用本地镜像: $processed_image"
            else
                # 从外网拉取
                print_info "从外网拉取: $processed_image"
                if docker pull "$processed_image"; then
                    print_success "拉取成功: $processed_image"
                else
                    print_error "拉取失败: $processed_image"
                    ((transfer_failed++))
                    continue
                fi
            fi
            
            # 标签并推送到私有仓库
            print_info "标签镜像: $processed_image -> $private_image"
            docker tag "$processed_image" "$private_image"
            
            print_info "推送到私有仓库: $private_image"
            if docker push "$private_image"; then
                print_success "推送成功: $private_image"
                ((transfer_success++))
            else
                print_error "推送失败: $private_image"
                ((transfer_failed++))
            fi
            
            # 清理本地镜像（可选，节省空间）
            if [[ "${CLEANUP_LOCAL_IMAGES:-false}" == "true" ]]; then
                docker rmi "$processed_image" "$private_image" 2>/dev/null || true
            fi
        fi
    done <<< "$images"
    
    print_info "镜像转发完成统计:"
    print_success "成功转发: $transfer_success 个镜像"
    if [[ $transfer_failed -gt 0 ]]; then
        print_error "转发失败: $transfer_failed 个镜像"
        exit 1
    fi
}

# 启动服务
start_services() {
    print_info "启动服务..."
    
    local compose_cmd
    if command -v docker-compose &> /dev/null; then
        compose_cmd="docker-compose"
    elif docker compose version &> /dev/null; then
        compose_cmd="docker compose"
    else
        print_error "Docker Compose 未找到"
        exit 1
    fi
    
    # 确定使用的环境文件
    local env_file="$ENV_FILE"
    
    # 设置环境变量
    export IMAGE_TAG="$IMAGE_TAG"
    export ENV_FILE="$env_file"
    
    print_info "使用环境文件: $env_file"
    print_info "镜像标签: $IMAGE_TAG"
    
    $compose_cmd --env-file "$env_file" up -d
    
    print_success "服务已启动"
    
    # 显示服务状态
    print_info "检查服务状态..."
    sleep 5
    $compose_cmd ps
}
show_help() {
    cat << 'EOF'
AI-Infra-Matrix 三环境统一构建部署脚本 v3.2.0

功能：支持开发环境、CI/CD服务器、生产环境的统一管理

环境类型：
  development   开发环境 - 本地构建和测试
  cicd         CI/CD环境 - 镜像转发和构建
  production   生产环境 - 内网部署

用法: ./build.sh <command> [options]

=== 通用命令 ===
  env                                     显示当前环境信息
  status                                  显示环境和服务状态
  version                                 显示脚本版本信息
  clean                                   清理Docker资源
  restore                                 恢复docker-compose.yml备份
  help                                    显示帮助信息

=== 开发环境命令 (development) ===
  build [tag]                            构建所有镜像
  dev-start [tag]                        构建并启动开发环境
  dev-stop                               停止开发环境
  start                                  启动服务（Docker Compose）

=== CI/CD环境命令 (cicd) ===
  transfer <registry> [tag]              转发镜像：外网 -> 内网仓库
  package <registry> [tag]               打包配置和部署脚本

=== 生产环境命令 (production) ===
  pull <registry> [tag]                  从私有仓库拉取镜像
  deploy-compose <registry> [tag]        使用Docker Compose部署
  deploy-helm <registry> [tag]           使用Kubernetes Helm部署

=== 选项 ===
  --force                                强制执行，跳过环境检查

=== 三环境使用场景 ===

1. 开发环境使用:
   $ export AI_INFRA_ENV_TYPE=development
   $ ./build.sh build v0.3.5                    # 构建所有镜像
   $ ./build.sh dev-start                       # 启动开发环境
   $ ./build.sh dev-stop                        # 停止开发环境

2. CI/CD服务器使用:
   $ export AI_INFRA_ENV_TYPE=cicd
   $ ./build.sh transfer registry.company.com/ai-infra v0.3.5   # 转发镜像
   $ ./build.sh package registry.company.com/ai-infra v0.3.5    # 打包配置

3. 生产环境使用:
   $ export AI_INFRA_ENV_TYPE=production
   $ ./build.sh pull registry.company.com/ai-infra v0.3.5       # 拉取镜像
   $ ./build.sh deploy-compose registry.company.com/ai-infra v0.3.5  # Docker部署
   $ ./build.sh deploy-helm registry.company.com/ai-infra v0.3.5     # K8s部署

=== 环境检测逻辑 ===
  1. 环境变量 AI_INFRA_ENV_TYPE (dev/cicd/prod)
  2. 文件 /etc/ai-infra-env 内容
  3. 自动检测：CI变量 → cicd，Kubernetes → production
  4. 默认：development

=== 配置文件 ===
  开发/CI环境: .env
  生产环境: .env.prod
  
=== 镜像仓库配置 ===
  环境变量: PRIVATE_REGISTRY
  或在配置文件中设置

=== 强制执行示例 ===
  ./build.sh build --force                      # 在任何环境构建
  ./build.sh transfer registry.example.com --force  # 强制转发镜像

=== 更多信息 ===
  docs/THREE_ENV_DEPLOYMENT_GUIDE.md  - 三环境部署指南
  docs/BUILD_USAGE_GUIDE.md           - 详细使用说明

EOF
}

# 主逻辑
main() {
    local command="${1:-help}"
    
    # 解析选项
    while [[ $# -gt 0 ]]; do
        case $1 in
            --env)
                ENV_TYPE="$2"
                shift 2
                ;;
            --force)
                FORCE_MODE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --cleanup)
                export CLEANUP_LOCAL_IMAGES=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            -*)
                print_warning "未知选项: $1"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    # 重新获取命令
    command="${1:-help}"
    
    # 加载环境配置
    load_environment_config
    
    print_info "当前环境配置:"
    print_info "  环境类型: $ENV_TYPE"
    print_info "  构建模式: $BUILD_MODE" 
    print_info "  环境文件: $ENV_FILE"
    print_info "  镜像版本: $IMAGE_TAG"
    print_info "  项目名称: $COMPOSE_PROJECT_NAME"
    if [[ -n "$PRIVATE_REGISTRY" ]]; then
        print_info "  私有仓库: $PRIVATE_REGISTRY"
    fi
    echo
    
    case "$command" in
        # 环境信息
        "env"|"environment")
            print_success "环境配置已显示"
            ;;
            
        # 开发环境命令
        "build")
            IMAGE_TAG="${2:-$IMAGE_TAG}"
            build_all_images
            ;;
            
        "dev-start")
            IMAGE_TAG="${2:-$IMAGE_TAG}"
            build_all_images
            start_services
            ;;
            
        "dev-stop")
            if command -v docker-compose &> /dev/null; then
                docker-compose down
            elif docker compose version &> /dev/null; then
                docker compose down
            else
                print_error "Docker Compose 未找到"
                exit 1
            fi
            print_success "服务已停止"
            ;;
            
# 备份并修改 docker-compose.yml 文件
backup_compose_file() {
    local compose_file="$1"
    local backup_file="$2"
    
    if [[ -f "$compose_file" ]]; then
        print_info "备份 docker-compose.yml -> ${backup_file}"
        cp "$compose_file" "$backup_file"
        print_success "备份完成: $backup_file"
    else
        print_error "找不到 docker-compose.yml 文件"
        exit 1
    fi
}

# 恢复 docker-compose.yml 文件
restore_compose_file() {
    local compose_file="$1"
    local backup_file="$2"
    
    if [[ -f "$backup_file" ]]; then
        print_info "恢复 docker-compose.yml <- ${backup_file}"
        cp "$backup_file" "$compose_file"
        print_success "恢复完成: $compose_file"
    else
        print_warning "找不到备份文件: $backup_file"
    fi
}

# 修改 docker-compose.yml 中的镜像引用
modify_compose_images() {
    local registry="$1"
    local tag="$2"
    local compose_file="$3"
    
    print_info "修改 docker-compose.yml 中的镜像引用..."
    print_info "私有仓库: $registry"
    print_info "镜像标签: $tag"
    
    # 创建临时文件
    local temp_file="${compose_file}.tmp"
    
    # 逐行处理文件
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*image:[[:space:]]*(.+)$ ]]; then
            local original_image="${BASH_REMATCH[1]}"
            # 移除引号
            original_image="${original_image//\"/}"
            original_image="${original_image//\'/}"
            
            # 替换环境变量
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            # 保持原有的缩进
            local indent=""
            if [[ "$line" =~ ^([[:space:]]*) ]]; then
                indent="${BASH_REMATCH[1]}"
            fi
            
            echo "${indent}image: $private_image"
            print_info "替换镜像: $original_image -> $private_image" >&2
        elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*JUPYTERHUB_IMAGE=(.+)$ ]]; then
            # 处理 JUPYTERHUB_IMAGE 环境变量
            local original_image="${BASH_REMATCH[1]}"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            # 保持原有的缩进
            local indent=""
            if [[ "$line" =~ ^([[:space:]]*) ]]; then
                indent="${BASH_REMATCH[1]}"
            fi
            
            echo "${indent}- JUPYTERHUB_IMAGE=$private_image"
            print_info "替换环境变量: JUPYTERHUB_IMAGE=$original_image -> $private_image" >&2
        else
            echo "$line"
        fi
    done < "$compose_file" > "$temp_file"
    
    # 替换原文件
    mv "$temp_file" "$compose_file"
    
    print_success "docker-compose.yml 修改完成"
}

# 从私有仓库拉取所有镜像
pull_all_images() {
    local registry="$1"
    local tag="$2"
    
    print_info "从私有仓库拉取所有镜像..."
    
    # 提取所有镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            print_info "拉取镜像: $private_image"
            if docker pull "$private_image"; then
                print_success "拉取成功: $private_image"
            else
                print_warning "拉取失败: $private_image"
            fi
        fi
    done <<< "$images"
}

# 从私有仓库部署服务（生产环境）
deploy_from_private_registry() {
    local registry="$1"
    local tag="$2"
    local deployment_method="${3:-docker-compose}"  # docker-compose or helm
    
    if [[ "$ENV_TYPE" != "production" ]] && [[ "$FORCE_MODE" != "true" ]]; then
        print_error "生产部署功能主要用于生产环境"
        print_info "如果确认要在当前环境执行，请使用 --force 参数"
        exit 1
    fi
    
    print_info "开始生产环境部署: $deployment_method"
    print_info "镜像仓库: $registry"
    print_info "镜像版本: $tag"
    
    case "$deployment_method" in
        "docker-compose"|"compose")
            deploy_with_docker_compose "$registry" "$tag"
            ;;
        "helm"|"k8s"|"kubernetes")
            deploy_with_helm "$registry" "$tag"
            ;;
        *)
            print_error "不支持的部署方式: $deployment_method"
            print_info "支持的部署方式: docker-compose, helm"
            exit 1
            ;;
    esac
}

# Docker Compose 部署
deploy_with_docker_compose() {
    local registry="$1"
    local tag="$2"
    
    print_info "使用 Docker Compose 部署..."
    
    # 备份并修改 docker-compose.yml
    backup_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
    modify_compose_images "$registry" "$tag" "$DOCKER_COMPOSE_FILE"
    
    # 拉取所有镜像
    print_info "拉取所有镜像..."
    pull_all_images "$registry" "$tag"
    
    # 启动服务
    start_services
    
    print_success "Docker Compose 部署完成"
}

# Helm 部署
deploy_with_helm() {
    local registry="$1"
    local tag="$2"
    
    print_info "使用 Helm 部署到 Kubernetes..."
    
    # 检查 kubectl 和 helm
    if ! command -v kubectl &> /dev/null; then
        print_error "kubectl 未安装或不在 PATH 中"
        exit 1
    fi
    
    if ! command -v helm &> /dev/null; then
        print_error "helm 未安装或不在 PATH 中"
        exit 1
    fi
    
    # 检查集群连接
    if ! kubectl cluster-info &> /dev/null; then
        print_error "无法连接到 Kubernetes 集群"
        exit 1
    fi
    
    # 切换到生产环境配置
    print_info "切换到生产环境配置..."
    if [[ -f "$SCRIPT_DIR/scripts/env-manager.sh" ]]; then
        "$SCRIPT_DIR/scripts/env-manager.sh" switch prod --force
    else
        print_warning "未找到环境管理脚本，跳过环境切换"
    fi
    
    # 同步环境变量到 Helm
    print_info "同步环境变量到 Helm..."
    if [[ -f "$SCRIPT_DIR/scripts/env-manager.sh" ]]; then
        "$SCRIPT_DIR/scripts/env-manager.sh" helm-sync
    else
        print_warning "未找到环境管理脚本，跳过环境变量同步"
    fi
    
    # 更新 Helm values 中的镜像仓库
    local helm_values_file="$SCRIPT_DIR/helm/ai-infra-matrix/values.yaml"
    if [[ -f "$helm_values_file" ]]; then
        # 备份 values.yaml
        cp "$helm_values_file" "$helm_values_file.backup-$(date +%Y%m%d-%H%M%S)"
        
        # 更新镜像仓库配置
        sed -i.bak "s|imageRegistry: \".*\"|imageRegistry: \"$registry\"|g" "$helm_values_file"
        sed -i.bak "s|imageTag: \".*\"|imageTag: \"$tag\"|g" "$helm_values_file"
        
        print_success "Helm values.yaml 已更新"
    fi
    
    # 创建命名空间
    local namespace="${K8S_NAMESPACE:-ai-infra-prod}"
    kubectl create namespace "$namespace" --dry-run=client -o yaml | kubectl apply -f -
    
    # 部署或升级
    local release_name="ai-infra-matrix"
    print_info "部署 Helm Chart..."
    
    if helm list -n "$namespace" | grep -q "$release_name"; then
        print_info "升级现有部署..."
        helm upgrade "$release_name" "$SCRIPT_DIR/helm/ai-infra-matrix" \
            --namespace "$namespace" \
            --timeout 20m \
            --wait
    else
        print_info "新建部署..."
        helm install "$release_name" "$SCRIPT_DIR/helm/ai-infra-matrix" \
            --namespace "$namespace" \
            --timeout 20m \
            --wait \
            --create-namespace
    fi
    
    print_success "Helm 部署完成"
    
    # 显示部署状态
    print_info "检查部署状态..."
    kubectl get pods -n "$namespace"
    kubectl get services -n "$namespace"
}

# 打包配置文件和部署脚本
package_configurations() {
    local registry="$1"
    local tag="$2"
    
    print_info "打包部署配置..."
    
    local package_dir="ai-infra-deploy-package"
    local package_file="ai-infra-deploy-${tag}.tar.gz"
    
    # 创建打包目录
    rm -rf "$package_dir"
    mkdir -p "$package_dir"
    
    # 复制必要文件
    cp -r "$SCRIPT_DIR/helm" "$package_dir/" 2>/dev/null || print_warning "未找到 helm 目录"
    cp -r "$SCRIPT_DIR/scripts" "$package_dir/" 2>/dev/null || print_warning "未找到 scripts 目录"
    cp "$SCRIPT_DIR/docker-compose.yml" "$package_dir/" 2>/dev/null || print_warning "未找到 docker-compose.yml"
    cp "$SCRIPT_DIR/.env.prod" "$package_dir/" 2>/dev/null || print_warning "未找到 .env.prod"
    cp "$SCRIPT_DIR/.env.prod.unified" "$package_dir/" 2>/dev/null || print_warning "未找到 .env.prod.unified"
    cp "$SCRIPT_DIR/build.sh" "$package_dir/"
    
    # 创建部署说明文件
    cat > "$package_dir/DEPLOY_README.md" << EOF
# AI Infrastructure Matrix 部署包

版本: $tag
镜像仓库: $registry
打包时间: $(date)

## 部署说明

### 1. Docker Compose 部署
\`\`\`bash
# 设置环境类型
export AI_INFRA_ENV_TYPE=production

# 从私有仓库部署
./build.sh deploy-compose $registry $tag
\`\`\`

### 2. Kubernetes 部署
\`\`\`bash
# 设置环境类型
export AI_INFRA_ENV_TYPE=production

# 使用 Helm 部署
./build.sh deploy-helm $registry $tag
\`\`\`

### 3. 手动配置
如果需要手动修改配置，请编辑 .env.prod 文件中的环境变量。

## 文件清单
- build.sh          - 主部署脚本
- docker-compose.yml - Docker Compose 配置
- .env.prod          - 生产环境配置
- helm/              - Kubernetes Helm Chart
- scripts/           - 辅助脚本

## 注意事项
1. 确保网络可以访问私有镜像仓库: $registry
2. 生产环境建议修改 .env.prod 中的密码配置
3. Kubernetes 部署需要正确配置 kubectl 访问权限
EOF
    
    # 打包
    tar -czf "$package_file" "$package_dir"
    rm -rf "$package_dir"
    
    print_success "部署包已创建: $package_file"
    print_info "部署包内容:"
    print_info "  - Docker Compose 配置"
    print_info "  - Kubernetes Helm Chart"
    print_info "  - 环境配置文件"
    print_info "  - 部署脚本和工具"
# 显示环境状态
show_environment_status() {
    print_info "环境状态:"
    print_info "  环境类型: $ENV_TYPE"
    print_info "  镜像标签: $IMAGE_TAG"
    print_info "  私有仓库: ${PRIVATE_REGISTRY:-'未配置'}"
    print_info "  配置文件: ${ENV_FILE}"
    
    if [[ "$ENV_TYPE" == "production" ]]; then
        print_info "  生产环境特殊配置:"
        print_info "    - Kubernetes命名空间: ${K8S_NAMESPACE:-ai-infra-prod}"
        print_info "    - 备份文件: ${DOCKER_COMPOSE_BACKUP}"
    fi
    
    # 检查Docker状态
    if command -v docker &> /dev/null; then
        print_info "  Docker 状态: 已安装"
        if docker ps &> /dev/null; then
            print_info "  Docker 服务: 运行中"
            local running_containers=$(docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "ai-infra|jupyterhub" 2>/dev/null | wc -l)
            print_info "  相关容器: $running_containers 个运行中"
        else
            print_warning "  Docker 服务: 未运行或权限不足"
        fi
    else
        print_warning "  Docker: 未安装"
    fi
    
    # 检查Kubernetes状态（生产环境）
    if [[ "$ENV_TYPE" == "production" ]] && command -v kubectl &> /dev/null; then
        if kubectl cluster-info &> /dev/null; then
            print_info "  Kubernetes: 已连接"
            local namespace="${K8S_NAMESPACE:-ai-infra-prod}"
            local pod_count=$(kubectl get pods -n "$namespace" 2>/dev/null | wc -l)
            if [[ $pod_count -gt 1 ]]; then
                print_info "  K8s Pods: $((pod_count-1)) 个在命名空间 $namespace"
            fi
        else
            print_warning "  Kubernetes: 无法连接集群"
        fi
    fi
}

# 清理Docker资源
clean_docker_resources() {
    print_info "清理Docker资源..."
    
    # 停止相关容器
    local containers=$(docker ps -q --filter "name=ai-infra" --filter "name=jupyterhub" 2>/dev/null)
    if [[ -n "$containers" ]]; then
        print_info "停止相关容器..."
        docker stop $containers
    fi
    
    # 清理未使用的镜像
    print_info "清理未使用的镜像..."
    docker image prune -f
    
    # 清理未使用的容器
    print_info "清理停止的容器..."
    docker container prune -f
    
    # 清理未使用的网络
    print_info "清理未使用的网络..."
    docker network prune -f
    
    print_success "Docker资源清理完成"
}

# 主函数
main() {
    # 检查是否有 --force 参数
    if [[ " $* " =~ " --force " ]]; then
        FORCE_MODE="true"
        # 移除 --force 参数
        set -- "${@/--force/}"
    fi
    
    local command="${1:-help}"
    
    case "$command" in
        "env")
            detect_environment
            load_environment_config
            print_info "当前环境: $ENV_TYPE"
            print_info "镜像标签: $IMAGE_TAG"
            print_info "配置文件: $ENV_FILE"
            [[ -n "$PRIVATE_REGISTRY" ]] && print_info "私有仓库: $PRIVATE_REGISTRY"
            ;;
            
        # 开发环境命令
        "build")
            if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "构建功能主要用于开发环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local tag="${2:-$IMAGE_TAG}"
            build_all_images "$tag"
            ;;
        
        "dev-start")
            if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "开发环境启动功能主要用于开发环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local tag="${2:-$IMAGE_TAG}"
            build_all_images "$tag"
            start_services
            ;;
        
        "dev-stop")
            if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "开发环境停止功能主要用于开发环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            print_info "停止开发环境..."
            docker-compose -f "$DOCKER_COMPOSE_FILE" down
            print_success "开发环境已停止"
            ;;
        
        # CI/CD环境命令
        "transfer")
            if [[ "$ENV_TYPE" != "cicd" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "镜像传输功能主要用于CI/CD环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local registry="${2:-$PRIVATE_REGISTRY}"
            local tag="${3:-$IMAGE_TAG}"
            if [[ -z "$registry" ]]; then
                print_error "请指定私有仓库地址"
                print_info "用法: $0 transfer <私有仓库地址> [标签]"
                exit 1
            fi
            
            transfer_images_to_private_registry "$registry" "$tag"
            ;;
        
        "package")
            if [[ "$ENV_TYPE" != "cicd" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "打包功能主要用于CI/CD环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local registry="${2:-$PRIVATE_REGISTRY}"
            local tag="${3:-$IMAGE_TAG}"
            if [[ -z "$registry" ]]; then
                print_error "请指定私有仓库地址"
                print_info "用法: $0 package <私有仓库地址> [标签]"
                exit 1
            fi
            
            package_configurations "$registry" "$tag"
            ;;
        
        # 生产环境命令
        "pull")
            if [[ "$ENV_TYPE" != "production" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "镜像拉取功能主要用于生产环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local registry="${2:-$PRIVATE_REGISTRY}"
            local tag="${3:-$IMAGE_TAG}"
            if [[ -z "$registry" ]]; then
                print_error "请指定私有仓库地址"
                print_info "用法: $0 pull <私有仓库地址> [标签]"
                exit 1
            fi
            
            pull_all_images "$registry" "$tag"
            ;;
        
        "deploy-compose")
            if [[ "$ENV_TYPE" != "production" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "生产部署功能主要用于生产环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local registry="${2:-$PRIVATE_REGISTRY}"
            local tag="${3:-$IMAGE_TAG}"
            if [[ -z "$registry" ]]; then
                print_error "请指定私有仓库地址"
                print_info "用法: $0 deploy-compose <私有仓库地址> [标签]"
                exit 1
            fi
            
            deploy_from_private_registry "$registry" "$tag" "docker-compose"
            ;;
        
        "deploy-helm")
            if [[ "$ENV_TYPE" != "production" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_warning "生产部署功能主要用于生产环境"
                print_info "如果确认要在当前环境执行，请使用 --force 参数"
                read -p "是否继续？(y/N): " confirm
                [[ "$confirm" != "y" && "$confirm" != "Y" ]] && exit 0
            fi
            
            local registry="${2:-$PRIVATE_REGISTRY}"
            local tag="${3:-$IMAGE_TAG}"
            if [[ -z "$registry" ]]; then
                print_error "请指定私有仓库地址"
                print_info "用法: $0 deploy-helm <私有仓库地址> [标签]"
                exit 1
            fi
            
            deploy_from_private_registry "$registry" "$tag" "helm"
            ;;
        
        # 通用命令
        "start")
            start_services
            ;;
        
        "restore")
            if [[ -f "$DOCKER_COMPOSE_BACKUP" ]]; then
                restore_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
            else
                print_warning "未找到 docker-compose.yml 备份文件"
            fi
            ;;
            
        "status")
            show_environment_status
            ;;
        
        "clean")
            clean_docker_resources
            ;;
        
        "version")
            echo "AI Infrastructure Matrix Build Script"
            echo "Version: $VERSION"
            echo "Environment: $ENV_TYPE"
            echo "Image Tag: $IMAGE_TAG"
            echo "Registry: ${PRIVATE_REGISTRY:-'未配置'}"
            ;;
        
        "help"|"-h"|"--help")
            show_help
            ;;
        
        *)
            print_error "未知命令: $1"
            print_info "使用 '$0 help' 查看可用命令"
            show_help
            exit 1
            ;;
    esac
}

# 执行主函数
main "$@"
