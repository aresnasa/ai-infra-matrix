#!/bin/bash

# AI-Infra-Matrix 三环境统一构建部署脚本
# 支持开发环境、CD服务器、生产环境三种部署模式
# 版本: v3.1.0

set -euo pipefail

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 打印带颜色的消息
print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
    echo -e "${RED}❌ $1${NC}"
}

# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 全局变量
PRIVATE_REGISTRY=""
IMAGE_TAG=""
DOCKER_COMPOSE_FILE="docker-compose.yml"
DOCKER_COMPOSE_BACKUP="docker-compose.yml.backup"

# 环境类型
ENV_TYPE=""  # development, cicd, production
BUILD_MODE="" # local, remote, deploy

# 配置文件
ENV_FILE=""
COMPOSE_PROJECT_NAME=""

# 功能开关
DRY_RUN=false
VERBOSE=false
FORCE_MODE=false

# 检测和设置环境类型
detect_environment() {
    # 优先使用环境变量
    if [[ -n "${AI_INFRA_ENV_TYPE:-}" ]]; then
        ENV_TYPE="$AI_INFRA_ENV_TYPE"
        print_info "使用环境变量设置的环境类型: $ENV_TYPE"
        return 0
    fi
    
    # 自动检测环境
    if [[ -f "/etc/ai-infra-env" ]]; then
        ENV_TYPE=$(cat /etc/ai-infra-env)
        print_info "检测到环境配置文件: $ENV_TYPE"
    elif command -v kubectl &> /dev/null && kubectl cluster-info &> /dev/null; then
        ENV_TYPE="production"
        print_info "检测到Kubernetes环境，设置为生产环境"
    elif [[ -n "${CI:-}" ]] || [[ -n "${JENKINS_URL:-}" ]] || [[ -n "${GITLAB_CI:-}" ]]; then
        ENV_TYPE="cicd"
        print_info "检测到CI/CD环境"
    else
        ENV_TYPE="development"
        print_info "默认设置为开发环境"
    fi
}

# 加载环境配置
load_environment_config() {
    detect_environment
    
    case "$ENV_TYPE" in
        "development")
            ENV_FILE=".env"
            BUILD_MODE="local"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-dev"
            ;;
        "cicd")
            ENV_FILE=".env"
            BUILD_MODE="remote"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-cicd"
            ;;
        "production")
            ENV_FILE=".env.prod"
            BUILD_MODE="deploy"
            COMPOSE_PROJECT_NAME="ai-infra-matrix-prod"
            ;;
        *)
            print_error "未知的环境类型: $ENV_TYPE"
            exit 1
            ;;
    esac
    
    # 加载环境文件
    if [[ -f "$SCRIPT_DIR/$ENV_FILE" ]]; then
        set -a
        source "$SCRIPT_DIR/$ENV_FILE"
        set +a
        print_success "已加载环境配置: $ENV_FILE"
    else
        print_warning "环境文件不存在: $ENV_FILE，使用默认配置"
    fi
    
    # 设置默认值
    IMAGE_TAG="${IMAGE_TAG:-v0.3.5}"
    PRIVATE_REGISTRY="${PRIVATE_REGISTRY:-}"
    
    print_info "当前环境配置:"
    print_info "  环境类型: $ENV_TYPE"
    print_info "  构建模式: $BUILD_MODE" 
    print_info "  环境文件: $ENV_FILE"
    print_info "  镜像版本: $IMAGE_TAG"
    print_info "  项目名称: $COMPOSE_PROJECT_NAME"
    if [[ -n "$PRIVATE_REGISTRY" ]]; then
        print_info "  私有仓库: $PRIVATE_REGISTRY"
    fi
}

# 获取镜像映射名称的函数
get_image_mapping() {
    local original_image="$1"
    
    case "$original_image" in
        "postgres:15-alpine")
            echo "postgres:15-alpine"
            ;;
        "redis:7-alpine")
            echo "redis:7-alpine"
            ;;
        "osixia/openldap:stable")
            echo "openldap:stable"
            ;;
        "osixia/phpldapadmin:stable")
            echo "phpldapadmin:stable"
            ;;
        "nginx:1.27-alpine")
            echo "nginx:1.27-alpine"
            ;;
        "quay.io/minio/minio:latest")
            echo "minio:latest"
            ;;
        "redislabs/redisinsight:latest")
            echo "redisinsight:latest"
            ;;
        "tecnativa/tcp-proxy")
            echo "tcp-proxy:latest"
            ;;
        "ai-infra-backend-init")
            echo "ai-infra-backend-init"
            ;;
        "ai-infra-backend")
            echo "ai-infra-backend"
            ;;
        "ai-infra-frontend")
            echo "ai-infra-frontend"
            ;;
        "ai-infra-jupyterhub")
            echo "ai-infra-jupyterhub"
            ;;
        "ai-infra-singleuser")
            echo "ai-infra-singleuser"
            ;;
        "ai-infra-saltstack")
            echo "ai-infra-saltstack"
            ;;
        "ai-infra-nginx")
            echo "ai-infra-nginx"
            ;;
        "ai-infra-gitea")
            echo "ai-infra-gitea"
            ;;
        *)
            # 默认处理：移除前缀域名
            echo "${original_image##*/}"
            ;;
    esac
}

# 解析镜像名称和标签
parse_image() {
    local image="$1"
    local name tag
    
    if [[ "$image" == *":"* ]]; then
        name="${image%:*}"
        tag="${image#*:}"
    else
        name="$image"
        tag="latest"
    fi
    
    echo "$name:$tag"
}

# 生成私有仓库镜像名称
get_private_image_name() {
    local original_image="$1"
    local registry="$2"
    
    # 移除 registry 末尾的斜杠（如果有）
    registry="${registry%/}"
    
    # 解析原始镜像
    local name tag
    if [[ "$original_image" == *":"* ]]; then
        name="${original_image%:*}"
        tag="${original_image#*:}"
    else
        name="$original_image"
        tag="latest"
    fi
    
    # 处理变量替换
    if [[ "$tag" == *"\${IMAGE_TAG"* ]]; then
        tag="${IMAGE_TAG}"
    fi
    
    # 获取映射名称
    local mapped_name=$(get_image_mapping "$name")
    if [[ -z "$mapped_name" ]]; then
        mapped_name=$(get_image_mapping "$original_image")
    fi
    
    if [[ -z "$mapped_name" ]]; then
        # 默认处理：移除前缀域名
        mapped_name="${name##*/}"
    fi
    
    # 如果映射名称包含标签，使用映射的标签
    if [[ "$mapped_name" == *":"* ]]; then
        echo "${registry}/${mapped_name}"
    else
        echo "${registry}/${mapped_name}:${tag}"
    fi
}

# 从 docker-compose.yml 提取所有镜像
extract_images_from_compose() {
    local compose_file="$1"
    
    # 使用更精确的方式提取镜像
    grep -E "^\s*image:\s*" "$compose_file" | \
    sed -E 's/^\s*image:\s*//g' | \
    sed -E 's/["'\''"]//g' | \
    sort -u
}

# 备份 docker-compose.yml 文件
backup_compose_file() {
    local compose_file="$1"
    local backup_file="$2"
    
    if [[ -f "$compose_file" ]]; then
        print_info "备份 docker-compose.yml -> ${backup_file}"
        cp "$compose_file" "$backup_file"
        print_success "备份完成: $backup_file"
    else
        print_error "找不到 docker-compose.yml 文件"
        exit 1
    fi
}

# 恢复 docker-compose.yml 文件
restore_compose_file() {
    local compose_file="$1"
    local backup_file="$2"
    
    if [[ -f "$backup_file" ]]; then
        print_info "恢复 docker-compose.yml <- ${backup_file}"
        cp "$backup_file" "$compose_file"
        print_success "恢复完成: $compose_file"
    else
        print_warning "找不到备份文件: $backup_file"
    fi
}

# 直接修改 docker-compose.yml 文件中的镜像
modify_compose_images() {
    local registry="$1"
    local tag="$2"
    local compose_file="$3"
    
    print_info "直接修改 docker-compose.yml 中的镜像..."
    print_info "私有仓库: $registry"
    print_info "镜像标签: $tag"
    
    # 创建临时文件
    local temp_file="${compose_file}.tmp"
    
    # 逐行处理文件
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*image:[[:space:]]*(.+)$ ]]; then
            local original_image="${BASH_REMATCH[1]}"
            # 移除引号
            original_image="${original_image//\"/}"
            original_image="${original_image//\'/}"
            
            # 替换环境变量
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            # 保持原有的缩进
            local indent=""
            if [[ "$line" =~ ^([[:space:]]*) ]]; then
                indent="${BASH_REMATCH[1]}"
            fi
            
            echo "${indent}image: $private_image"
            print_info "替换镜像: $original_image -> $private_image" >&2
        elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*JUPYTERHUB_IMAGE=(.+)$ ]]; then
            # 处理 JUPYTERHUB_IMAGE 环境变量
            local original_image="${BASH_REMATCH[1]}"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            # 保持原有的缩进
            local indent=""
            if [[ "$line" =~ ^([[:space:]]*) ]]; then
                indent="${BASH_REMATCH[1]}"
            fi
            
            echo "${indent}- JUPYTERHUB_IMAGE=$private_image"
            print_info "替换环境变量: JUPYTERHUB_IMAGE=$original_image -> $private_image" >&2
        else
            echo "$line"
        fi
    done < "$compose_file" > "$temp_file"
    
    # 替换原文件
    mv "$temp_file" "$compose_file"
    
    print_success "docker-compose.yml 修改完成"
}

# 构建所有本地镜像（开发环境）
build_all_images() {
    print_info "开始构建所有镜像..."
    
    if [[ "$ENV_TYPE" != "development" ]]; then
        print_error "镜像构建仅支持开发环境"
        exit 1
    fi
    
    # 调用 all-ops.sh 进行构建
    local all_ops_script="$SCRIPT_DIR/scripts/all-ops.sh"
    
    if [[ ! -f "$all_ops_script" ]]; then
        print_error "找不到构建脚本: $all_ops_script"
        exit 1
    fi
    
    chmod +x "$all_ops_script"
    
    print_info "调用构建脚本..."
    if [[ "$VERBOSE" == "true" ]]; then
        "$all_ops_script" build --version "$IMAGE_TAG" --verbose
    else
        "$all_ops_script" build --version "$IMAGE_TAG"
    fi
    
    print_success "所有镜像构建完成"
}

# 下载外网镜像并推送到内网仓库（CD环境）
transfer_images_to_private_registry() {
    local registry="$1"
    local tag="$2"
    
    if [[ "$ENV_TYPE" != "cicd" ]] && [[ "$FORCE_MODE" != "true" ]]; then
        print_error "镜像转发功能主要用于CI/CD环境"
        print_info "如果确认要在当前环境执行，请使用 --force 参数"
        exit 1
    fi
    
    print_info "开始镜像转发: 外网 -> $registry"
    
    # 检查Docker登录状态
    if ! docker info > /dev/null 2>&1; then
        print_error "Docker服务未运行"
        exit 1
    fi
    
    # 获取所有需要的镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    local transfer_success=0
    local transfer_failed=0
    
    print_info "开始转发镜像列表:"
    echo "$images" | while read -r original_image; do
        if [[ -n "$original_image" ]]; then
            echo "  - $original_image"
        fi
    done
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量
            local processed_image="$original_image"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                processed_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                processed_image="${processed_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$processed_image" "$registry")
            
            print_info "转发镜像: $processed_image -> $private_image"
            
            # 检查本地是否已存在
            if docker image inspect "$processed_image" >/dev/null 2>&1; then
                print_info "使用本地镜像: $processed_image"
            else
                # 从外网拉取
                print_info "从外网拉取: $processed_image"
                if docker pull "$processed_image"; then
                    print_success "拉取成功: $processed_image"
                else
                    print_error "拉取失败: $processed_image"
                    ((transfer_failed++))
                    continue
                fi
            fi
            
            # 标签并推送到私有仓库
            print_info "标签镜像: $processed_image -> $private_image"
            docker tag "$processed_image" "$private_image"
            
            print_info "推送到私有仓库: $private_image"
            if docker push "$private_image"; then
                print_success "推送成功: $private_image"
                ((transfer_success++))
            else
                print_error "推送失败: $private_image"
                ((transfer_failed++))
            fi
            
            # 清理本地镜像（可选，节省空间）
            if [[ "${CLEANUP_LOCAL_IMAGES:-false}" == "true" ]]; then
                docker rmi "$processed_image" "$private_image" 2>/dev/null || true
            fi
        fi
    done <<< "$images"
    
    print_info "镜像转发完成统计:"
    print_success "成功转发: $transfer_success 个镜像"
    if [[ $transfer_failed -gt 0 ]]; then
        print_error "转发失败: $transfer_failed 个镜像"
        exit 1
    fi
}

# 从私有仓库部署服务（生产环境）
deploy_from_private_registry() {
    local registry="$1"
    local tag="$2"
    local deployment_method="${3:-docker-compose}"  # docker-compose or helm
    
    if [[ "$ENV_TYPE" != "production" ]] && [[ "$FORCE_MODE" != "true" ]]; then
        print_error "生产部署功能主要用于生产环境"
        print_info "如果确认要在当前环境执行，请使用 --force 参数"
        exit 1
    fi
    
    print_info "开始生产环境部署: $deployment_method"
    print_info "镜像仓库: $registry"
    print_info "镜像版本: $tag"
    
    case "$deployment_method" in
        "docker-compose"|"compose")
            deploy_with_docker_compose "$registry" "$tag"
            ;;
        "helm"|"k8s"|"kubernetes")
            deploy_with_helm "$registry" "$tag"
            ;;
        *)
            print_error "不支持的部署方式: $deployment_method"
            print_info "支持的部署方式: docker-compose, helm"
            exit 1
            ;;
    esac
}

# Docker Compose 部署
deploy_with_docker_compose() {
    local registry="$1"
    local tag="$2"
    
    print_info "使用 Docker Compose 部署..."
    
    # 备份并修改 docker-compose.yml
    backup_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
    modify_compose_images "$registry" "$tag" "$DOCKER_COMPOSE_FILE"
    
    # 拉取所有镜像
    print_info "拉取所有镜像..."
    pull_all_images "$registry" "$tag"
    
    # 启动服务
    start_services
    
    print_success "Docker Compose 部署完成"
}

# Helm 部署
deploy_with_helm() {
    local registry="$1"
    local tag="$2"
    
    print_info "使用 Helm 部署到 Kubernetes..."
    
    # 检查 kubectl 和 helm
    if ! command -v kubectl &> /dev/null; then
        print_error "kubectl 未安装或不在 PATH 中"
        exit 1
    fi
    
    if ! command -v helm &> /dev/null; then
        print_error "helm 未安装或不在 PATH 中"
        exit 1
    fi
    
    # 检查集群连接
    if ! kubectl cluster-info &> /dev/null; then
        print_error "无法连接到 Kubernetes 集群"
        exit 1
    fi
    
    # 切换到生产环境配置
    print_info "切换到生产环境配置..."
    "$SCRIPT_DIR/scripts/env-manager.sh" switch prod --force
    
    # 同步环境变量到 Helm
    print_info "同步环境变量到 Helm..."
    "$SCRIPT_DIR/scripts/env-manager.sh" helm-sync
    
    # 更新 Helm values 中的镜像仓库
    local helm_values_file="$SCRIPT_DIR/helm/ai-infra-matrix/values.yaml"
    if [[ -f "$helm_values_file" ]]; then
        # 备份 values.yaml
        cp "$helm_values_file" "$helm_values_file.backup-$(date +%Y%m%d-%H%M%S)"
        
        # 更新镜像仓库配置
        sed -i.bak "s|imageRegistry: \".*\"|imageRegistry: \"$registry\"|g" "$helm_values_file"
        sed -i.bak "s|imageTag: \".*\"|imageTag: \"$tag\"|g" "$helm_values_file"
        
        print_success "Helm values.yaml 已更新"
    fi
    
    # 创建命名空间
    local namespace="${K8S_NAMESPACE:-ai-infra-prod}"
    kubectl create namespace "$namespace" --dry-run=client -o yaml | kubectl apply -f -
    
    # 部署或升级
    local release_name="ai-infra-matrix"
    print_info "部署 Helm Chart..."
    
    if helm list -n "$namespace" | grep -q "$release_name"; then
        print_info "升级现有部署..."
        helm upgrade "$release_name" "$SCRIPT_DIR/helm/ai-infra-matrix" \
            --namespace "$namespace" \
            --timeout 20m \
            --wait
    else
        print_info "新建部署..."
        helm install "$release_name" "$SCRIPT_DIR/helm/ai-infra-matrix" \
            --namespace "$namespace" \
            --timeout 20m \
            --wait \
            --create-namespace
    fi
    
    print_success "Helm 部署完成"
    
    # 显示部署状态
    print_info "检查部署状态..."
    kubectl get pods -n "$namespace"
    kubectl get services -n "$namespace"
}

# 标签并推送所有镜像
# 标签并推送所有镜像
tag_and_push_all_images() {
    local registry="$1"
    local tag="$2"
    
    print_info "标签并推送所有镜像到私有仓库..."
    
    # 提取所有镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量
            local processed_image="$original_image"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                processed_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                processed_image="${processed_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$processed_image" "$registry")
            
            print_info "处理镜像: $processed_image -> $private_image"
            
            # 检查本地是否存在原始镜像
            if docker image inspect "$processed_image" >/dev/null 2>&1; then
                print_info "标签镜像: $processed_image -> $private_image"
                docker tag "$processed_image" "$private_image"
                
                print_info "推送镜像: $private_image"
                if docker push "$private_image"; then
                    print_success "推送成功: $private_image"
                else
                    print_error "推送失败: $private_image"
                fi
            else
                print_warning "本地镜像不存在: $processed_image"
                
                # 尝试从 Docker Hub 拉取并转推
                print_info "尝试从公共仓库拉取: $processed_image"
                if docker pull "$processed_image"; then
                    print_info "标签镜像: $processed_image -> $private_image"
                    docker tag "$processed_image" "$private_image"
                    
                    print_info "推送镜像: $private_image"
                    if docker push "$private_image"; then
                        print_success "推送成功: $private_image"
                    else
                        print_error "推送失败: $private_image"
                    fi
                else
                    print_error "无法拉取镜像: $processed_image"
                fi
            fi
        fi
    done <<< "$images"
}
# 打包配置文件和部署脚本
package_configurations() {
    local registry="$1"
    local tag="$2"
    
    print_info "打包部署配置..."
    
    local package_dir="ai-infra-deploy-package"
    local package_file="ai-infra-deploy-${tag}.tar.gz"
    
    # 创建打包目录
    rm -rf "$package_dir"
    mkdir -p "$package_dir"
    
    # 复制必要文件
    cp -r "$SCRIPT_DIR/helm" "$package_dir/"
    cp -r "$SCRIPT_DIR/scripts" "$package_dir/"
    cp "$SCRIPT_DIR/docker-compose.yml" "$package_dir/"
    cp "$SCRIPT_DIR/.env.prod" "$package_dir/"
    cp "$SCRIPT_DIR/.env.prod.unified" "$package_dir/"
    cp "$SCRIPT_DIR/build.sh" "$package_dir/"
    
    # 创建部署说明文件
    cat > "$package_dir/DEPLOY_README.md" << EOF
# AI Infrastructure Matrix 部署包

版本: $tag
镜像仓库: $registry
打包时间: $(date)

## 部署说明

### 1. Docker Compose 部署
\`\`\`bash
# 设置环境类型
export AI_INFRA_ENV_TYPE=production

# 从私有仓库部署
./build.sh deploy-compose $registry $tag
\`\`\`

### 2. Kubernetes 部署
\`\`\`bash
# 设置环境类型
export AI_INFRA_ENV_TYPE=production

# 使用 Helm 部署
./build.sh deploy-helm $registry $tag
\`\`\`

### 3. 手动配置
如果需要手动修改配置，请编辑 .env.prod 文件中的环境变量。

## 文件清单
- build.sh          - 主部署脚本
- docker-compose.yml - Docker Compose 配置
- .env.prod          - 生产环境配置
- helm/              - Kubernetes Helm Chart
- scripts/           - 辅助脚本

## 注意事项
1. 确保网络可以访问私有镜像仓库: $registry
2. 生产环境建议修改 .env.prod 中的密码配置
3. Kubernetes 部署需要正确配置 kubectl 访问权限
EOF
    
    # 打包
    tar -czf "$package_file" "$package_dir"
    rm -rf "$package_dir"
    
    print_success "部署包已创建: $package_file"
    print_info "部署包内容:"
    print_info "  - Docker Compose 配置"
    print_info "  - Kubernetes Helm Chart"
    print_info "  - 环境配置文件"
    print_info "  - 部署脚本和工具"
}

# 拉取所有镜像到本地
pull_all_images() {
    local registry="$1"
    local tag="$2"
    
    print_info "从私有仓库拉取所有镜像..."
    
    # 提取所有镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                original_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/$tag}"
                original_image="${original_image//\$\{IMAGE_TAG\}/$tag}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            
            print_info "拉取镜像: $private_image"
            if docker pull "$private_image"; then
                print_success "拉取成功: $private_image"
            else
                print_warning "拉取失败: $private_image"
            fi
        fi
    done <<< "$images"
}_image"
                
                # 尝试从 Docker Hub 拉取并转推
                print_info "尝试从公共仓库拉取: $processed_image"
                if docker pull "$processed_image"; then
                    print_info "标签镜像: $processed_image -> $private_image"
                    docker tag "$processed_image" "$private_image"
                    
                    print_info "推送镜像: $private_image"
                    if docker push "$private_image"; then
                        print_success "推送成功: $private_image"
                    else
                        print_error "推送失败: $private_image"
                    fi
                else
                    print_error "无法拉取镜像: $processed_image"
                fi
            fi
        fi
    done <<< "$images"
}

# 启动服务
start_services() {
    print_info "启动服务..."
    
    local compose_cmd
    if command -v docker-compose &> /dev/null; then
        compose_cmd="docker-compose"
    elif docker compose version &> /dev/null; then
        compose_cmd="docker compose"
    else
        print_error "Docker Compose 未找到"
        exit 1
    fi
    
    # 确定使用的环境文件
    local env_file=".env"
    if [[ -n "$PRIVATE_REGISTRY" ]]; then
        env_file=".env.prod"
    fi
    
    # 设置环境变量
    export IMAGE_TAG="$IMAGE_TAG"
    export ENV_FILE="$env_file"
    
    print_info "使用环境文件: $env_file"
    print_info "镜像标签: $IMAGE_TAG"
    
    $compose_cmd --env-file "$env_file" up -d
    
    print_success "服务已启动"
    
    # 显示服务状态
    print_info "检查服务状态..."
    sleep 5
    $compose_cmd ps
}

# 停止服务
stop_services() {
    print_info "停止所有服务..."
    
    if command -v docker-compose &> /dev/null; then
        docker-compose down
    elif docker compose version &> /dev/null; then
        docker compose down
    else
        print_error "Docker Compose 未找到"
        exit 1
    fi
    
    print_success "服务已停止"
}

# 显示镜像映射
show_image_mappings() {
    local registry="${1:-<private-registry>}"
    
    print_info "镜像映射表 - 目标仓库: $registry"
    echo ""
    
    printf "%-40s -> %-60s\n" "原始镜像" "私有仓库镜像"
    printf "%-40s -> %-60s\n" "----------------------------------------" "------------------------------------------------------------"
    
    # 从 docker-compose.yml 提取实际使用的镜像
    local images=$(extract_images_from_compose "$DOCKER_COMPOSE_FILE")
    
    while IFS= read -r original_image; do
        if [[ -n "$original_image" ]]; then
            # 替换环境变量显示
            local display_image="$original_image"
            if [[ "$original_image" == *"\${IMAGE_TAG"* ]]; then
                display_image="${original_image//\$\{IMAGE_TAG:-v0.0.3.3\}/\${IMAGE_TAG\}}"
                display_image="${display_image//\$\{IMAGE_TAG\}/\${IMAGE_TAG\}}"
            fi
            
            local private_image=$(get_private_image_name "$original_image" "$registry")
            # 替换实际的镜像标签为变量显示
            private_image="${private_image//:$IMAGE_TAG/:\${IMAGE_TAG\}}"
            
            printf "%-40s -> %-60s\n" "$display_image" "$private_image"
        fi
    done <<< "$images"
    
    echo ""
}

# 显示帮助信息
show_help() {
    cat << EOF
AI-Infra-Matrix 三环境统一构建部署脚本 v3.1.0

功能：支持开发环境、CI/CD服务器、生产环境的统一管理

环境类型：
  development   开发环境 - 本地构建和测试
  cicd         CI/CD环境 - 镜像转发和构建
  production   生产环境 - 内网部署

用法: $0 <command> [options]

=== 通用命令 ===
  env                                     显示当前环境信息
  help                                    显示帮助信息

=== 开发环境命令 (development) ===
  build [tag]                            构建所有镜像
  dev-start [tag]                        构建并启动开发环境
  dev-stop                               停止开发环境

=== CI/CD环境命令 (cicd) ===
  transfer <registry> [tag]              转发镜像：外网 -> 内网仓库
  package <registry> [tag]               打包所有配置和镜像

=== 生产环境命令 (production) ===
  deploy-compose <registry> [tag]        使用Docker Compose部署
  deploy-helm <registry> [tag]           使用Helm部署到Kubernetes
  pull <registry> [tag]                  从私有仓库拉取镜像

=== 兼容命令 (向后兼容) ===
  registry <registry_url> [tag]          设置私有仓库并修改配置
  push <registry_url> [tag]              推送镜像到仓库
  start [registry_url] [tag]             启动服务
  stop                                   停止服务
  images [registry_url]                  显示镜像映射表
  restore                                恢复配置文件

=== 选项 ===
  --env <type>                           强制指定环境类型 (dev/cicd/prod)
  --force                                强制执行，跳过环境检查
  --verbose                              详细输出
  --dry-run                              预览模式，不执行实际操作
  --cleanup                              清理本地镜像（CI/CD环境）

=== 三环境使用场景 ===

1. 开发环境使用:
   \$ export AI_INFRA_ENV_TYPE=development
   \$ $0 build v0.3.5                    # 构建所有镜像
   \$ $0 dev-start                       # 启动开发环境

2. CI/CD服务器使用:
   \$ export AI_INFRA_ENV_TYPE=cicd
   \$ $0 transfer registry.company.com/ai-infra v0.3.5
   
3. 生产服务器使用:
   \$ export AI_INFRA_ENV_TYPE=production
   \$ $0 deploy-compose registry.company.com/ai-infra v0.3.5
   \$ $0 deploy-helm registry.company.com/ai-infra v0.3.5

=== 环境变量 ===
  AI_INFRA_ENV_TYPE                      环境类型 (development/cicd/production)
  IMAGE_TAG                              镜像标签 (默认: v0.3.5)
  PRIVATE_REGISTRY                       私有仓库地址
  CLEANUP_LOCAL_IMAGES                   CI/CD环境清理本地镜像 (true/false)

=== 配置文件 ===
  .env                                   开发/CI/CD环境配置
  .env.prod                              生产环境配置
  /etc/ai-infra-env                      系统级环境类型标识

=== 示例 ===
  # 开发环境完整流程
  $0 --env development build v0.3.5
  $0 dev-start
  
  # CI/CD环境镜像转发
  $0 --env cicd transfer registry.internal.com/ai-infra v0.3.5 --cleanup
  
  # 生产环境Kubernetes部署
  $0 --env production deploy-helm registry.internal.com/ai-infra v0.3.5

EOF
}

# 清理配置文件
clean_configs() {
    restore_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
}

# 主逻辑
main() {
    local command="${1:-help}"
    
    # 解析选项
    while [[ $# -gt 0 ]]; do
        case $1 in
            --env)
                ENV_TYPE="$2"
                shift 2
                ;;
            --force)
                FORCE_MODE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --cleanup)
                export CLEANUP_LOCAL_IMAGES=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            -*)
                print_warning "未知选项: $1"
                shift
                ;;
            *)
                break
                ;;
        esac
    done
    
    # 重新获取命令
    command="${1:-help}"
    
    # 加载环境配置
    load_environment_config
    
    case "$command" in
        # 环境信息
        "env"|"environment")
            print_info "当前环境配置:"
            print_info "  环境类型: $ENV_TYPE"
            print_info "  构建模式: $BUILD_MODE"
            print_info "  环境文件: $ENV_FILE"
            print_info "  镜像版本: $IMAGE_TAG"
            print_info "  项目名称: $COMPOSE_PROJECT_NAME"
            if [[ -n "$PRIVATE_REGISTRY" ]]; then
                print_info "  私有仓库: $PRIVATE_REGISTRY"
            fi
            ;;
            
        # 开发环境命令
        "build")
            if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_error "build 命令仅在开发环境中使用"
                print_info "当前环境: $ENV_TYPE，如需强制执行请使用 --force"
                exit 1
            fi
            IMAGE_TAG="${2:-$IMAGE_TAG}"
            build_all_images
            ;;
            
        "dev-start")
            if [[ "$ENV_TYPE" != "development" ]] && [[ "$FORCE_MODE" != "true" ]]; then
                print_error "dev-start 命令仅在开发环境中使用"
                exit 1
            fi
            IMAGE_TAG="${2:-$IMAGE_TAG}"
            build_all_images
            start_services
            ;;
            
        "dev-stop")
            stop_services
            ;;
            
        # CI/CD环境命令
        "transfer")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 transfer <registry_url> [tag]"
                print_info "示例: $0 transfer registry.company.com/ai-infra v0.3.5"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            transfer_images_to_private_registry "$PRIVATE_REGISTRY" "$IMAGE_TAG"
            ;;
            
        "package")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 package <registry_url> [tag]"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            # 先转发镜像
            transfer_images_to_private_registry "$PRIVATE_REGISTRY" "$IMAGE_TAG"
            # 打包配置文件
            package_configurations "$PRIVATE_REGISTRY" "$IMAGE_TAG"
            ;;
            
        # 生产环境命令
        "deploy-compose")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 deploy-compose <registry_url> [tag]"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            deploy_from_private_registry "$PRIVATE_REGISTRY" "$IMAGE_TAG" "docker-compose"
            ;;
            
        "deploy-helm")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 deploy-helm <registry_url> [tag]"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            deploy_from_private_registry "$PRIVATE_REGISTRY" "$IMAGE_TAG" "helm"
            ;;
            
        # 兼容性命令 (向后兼容)
        "registry")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 registry <registry_url> [tag]"
                print_info "示例: $0 registry registry.company.com/ai-infra v0.3.5"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            backup_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
            modify_compose_images "$PRIVATE_REGISTRY" "$IMAGE_TAG" "$DOCKER_COMPOSE_FILE"
            ;;
            
        "pull")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 pull <registry_url> [tag]"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            pull_all_images "$PRIVATE_REGISTRY" "$IMAGE_TAG"
            ;;
            
        "push")
            if [[ $# -lt 2 ]]; then
                print_error "用法: $0 push <registry_url> [tag]"
                exit 1
            fi
            PRIVATE_REGISTRY="$2"
            IMAGE_TAG="${3:-$IMAGE_TAG}"
            tag_and_push_all_images "$PRIVATE_REGISTRY" "$IMAGE_TAG"
            ;;
            
        "start")
            if [[ $# -ge 2 ]]; then
                PRIVATE_REGISTRY="$2"
                IMAGE_TAG="${3:-$IMAGE_TAG}"
                backup_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
                modify_compose_images "$PRIVATE_REGISTRY" "$IMAGE_TAG" "$DOCKER_COMPOSE_FILE"
            fi
            start_services
            ;;
            
        "stop")
            stop_services
            ;;
            
        "images")
            show_image_mappings "${2:-<private-registry>}"
            ;;
            
        "restore")
            restore_compose_file "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_BACKUP"
            ;;
            
        "clean")
            clean_configs
            ;;
            
        "help"|"--help"|"-h")
            show_help
            ;;
            
        *)
            # 传递给 all-ops.sh 处理其他命令
            ALL_OPS_SCRIPT="$SCRIPT_DIR/scripts/all-ops.sh"
            
            if [ ! -f "$ALL_OPS_SCRIPT" ]; then
                print_error "找不到 $ALL_OPS_SCRIPT"
                print_info "可用命令请查看: $0 help"
                exit 1
            fi
            
            # 确保脚本可执行
            chmod +x "$ALL_OPS_SCRIPT"
            
            # 传递所有参数给 all-ops.sh
            exec "$ALL_OPS_SCRIPT" "$@"
            ;;
    esac
}

# 执行主函数
main "$@"
